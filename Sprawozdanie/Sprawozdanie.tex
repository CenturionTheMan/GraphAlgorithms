\documentclass{article}

\usepackage[margin = 0.7in]{geometry}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{tabularx}
\usepackage[table,xcdraw]{xcolor}
\usepackage{lipsum}
\usepackage{titlesec}
\usepackage{minted}
\usepackage{xcolor}

\usepackage{csvsimple}

%TABS
\usepackage[]{booktabs}
\usepackage{tabularray}
\usepackage{multirow}


\title{Zadanie projektowe nr 1}
\author{Michał Dziedziak}
\date{\today}


\titlespacing\section{0pt}{12pt plus 4pt minus 2pt}{0pt plus 2pt minus 2pt}
\titlespacing\subsection{0pt}{12pt plus 4pt minus 2pt}{0pt plus 2pt minus 2pt}
\titlespacing\subsubsection{0pt}{12pt plus 4pt minus 2pt}{0pt plus 2pt minus 2pt}
\setlength{\parskip}{\baselineskip}%
\setlength{\parindent}{0pt}%

\newcommand{\squeezeup}{\vspace{-5mm}}


\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{5cm}
        \rule{500pt}{1pt}\\
        \vspace*{0.5cm}
        \LARGE
        \textbf{Zadanie projektowe nr 2}\\
        \Large
        Badanie efektywności algorytmów grafowych w zależności od rozmiaru instancji
        oraz sposobu reprezentacji grafu w pamięci komputera \\
        \vspace*{0.5cm}
        \rule{500pt}{1pt}
    \end{center}

    \vspace*{12cm}

    {\raggedright
        \large
        \textbf{Autor sprawozdania:} Michał Dziedziak,  263901\\
        \textbf{Nazwisko i Imię prowadzącego kurs:} Mgr. inż. Antoni Sterna\\
        \textbf{Dzień i godzina zajęć:} Wtorek, 15:15 - 16:55 TN
    }
\end{titlepage}


\tableofcontents
\listoftables
% \listoffigures


\newpage

%CONTENT
\section{Wstęp}
    \subsection{Zarys projektu}
    W ramach projektu w języku C++ zaimplementowane zostały wybrane algorytmy znajdowania najmniejszego
    drzewa rozpinającego i najkrótszej ścieżki w grafie. Do reprezentacji grafów użyta została macierz sąsiedztw i lista sąsiedztw. 
    Poniższe sprawozdanie bada zależność czasu od ilości wierzchołków i gęstości grafu podczas wykonywania poszczególnych algorytmów.

    \subsection{Algorytmy}
        \subsubsection{Zaimplemtntowane algorytmy}
            \begin{itemize}
                \item Najmniejsze drzewo rozpinające
                \begin{itemize}
                    \item Algorytm Prima
                    \item Algorytm Kruskala
                \end{itemize}
                \item Najkrótsza ścieżka w grafie
                \begin{itemize}
                    \item Algorytm Dijkstry
                    \item Algorytm Bellmana-Forda
                \end{itemize}
            \end{itemize}

    \subsubsection{Teoretyczne złożoności obliczeniowe}
    W tej sekcji przedstawię teoretyczne złożoności obliczeniowe operacji na grafach, celem późniejszego porównania ich z wynikami testów.
    \begin{center}    
        \begin{tabular}[H]{| c | c | c | c | c |}
            \hline
            Algorytm & Reprezentacja grafu & Pesymistyczna złożoność & Średnia złożoność &  Optymistyczna złożoność\\ \hline \hline
            Prima & Macierz sąsiedztwa & $O(V^2 logV)$ & $O((V + E)logV)$ & $O(ElogV)$ \\ \hline
            Prima & Lista sąsiedztwa & $O((V+E)logV)$ & $O((V+E)logV)$ & $O((V+E)logV)$ \\ \hline
            Kruskal & Macierz sąsiedztwa & $O(E log E)$ & $O(E log E)$ & $O(E log E)$ \\ \hline
            Kruskal & Lista sąsiedztwa & $O(E log E)$ & $O(E log E)$ & $O(E log E)$ \\ \hline
            Dijkstra & Macierz sąsiedztwa & $O(V^2 log V)$ & $O(V^2 log V)$ & $O(V^2 log V)$ \\ \hline
            Dijkstra & Lista sąsiedztwa & $O((E+V)logV)$ & $O((E+V)logV)$ & $O(E+VlogV)$ \\ \hline
            Bellman-Ford & Macierz sąsiedztwa & $O(V^2)$ & $O(V^2)$ & $O(V^2)$ \\ \hline
            Bellman-Ford & Lista sąsiedztwa & $O(V^2)$ & $O(V^2)$ & $O(V^2)$ \\ \hline
        \end{tabular}
    \end{center}

\section{Plan eksperymentu}
    \subsection{Założenia}
        \begin{itemize}
            \item Macierz sąsiedztwa i niektóre algorytmy wykorzystują umowną wartość maksymalnego int'a do reprezentowania 
            braku krawędzi pomiędzy wierzchołkami lub nieskończonego kosztu dojścia do danego wierzchołka.
            \item Wagi krawędzi są liczbami całkowitymi.
            \item Testy wykonywane są dla grafów posiadających od 50 do 500 wierzchołków (z krokiem równym 50). Dla każdej liczby wierzchołków
            wykonywane są cztery testy dla gęstości grafu równej kolejno 25\%, 50\%, 75\%, 99\%. Test dla każdej kombinacji ilości wierzchołków
            i gęstości grafu wykonywany jest sto razy i ostateczny czas jest średnią tych czasów.
        \end{itemize}

    \subsection{Generowanie grafu}
    Dla każdego testu generowany jest nowy graf. Algorytm analizuje każde potencjalne połączenie pomiędzy wierzchołkami i ustawia je lub nie (ma na to 50\% szans). 
    Kolejno waga takiego połączenia losowana jest z zakresu od 0 lub -1000 (w zależności od algorytmu) do 1000. Algorytm losuje czy dodaje nowe połączenie do momentu,
    kiedy wszystkie pozostałe połączenia muszą zostać stworzone w celu zapewnienia wymaganej gęstości (wtedy tworzy pozostałe wierzchołki z losowymi wagami).
    
    \subsection{Pomiar czasu}
    Do pomiaru czasu została napisana osobna klasa "Timer". Korzysta ona z funkcji QueryPerformanceCounter\\
    i QueryPerformanceFrequency umożliwiających pomiar czasu z dokładnością do mikro sekund. Klasa ta określa upływ czasu, bazując na dokładnym liczniku.
    
    \subsection{Losowanie populacji}
    Do losowania populacji również została napisana osobna klasa RandomGenerator. Umożliwia ona losowanie pojedynczych liczb lub całych zbiorów.
    Korzysta z mt19937 - generatora liczb pseudolosowych.

\section{Dane określające Wyniki pomiarów}
    
    \subsection{Algorytmy znajdowania minimalnego drzewa rozpinającego}
        
        \subsubsection{Algorytm Prima i macierz sąsiedztwa}
            \begin{table}[H]
                \centering
                \begin{tabular}{|c|c|c|}%
                    \hline
                    \bfseries Liczba wierzchołków & \bfseries Gęstość & \bfseries Czas $[ms]$% specify table head
                    \csvreader[head to column names]{Tests/Matrix_Prima.csv}{}% use head of csv as column names
                    {\\\hline\csvcoli&\csvcolii&\csvcoliii}\\
                    \hline
                \end{tabular}
                \caption{Pomiary algorytmu Prima na macierzy sąsiedztwa}
            \end{table}

        \subsubsection{Algorytm Prima i lista sąsiedztwa}
            \begin{table}[H]
                \centering
                \begin{tabular}{|c|c|c|}%
                    \hline
                    \bfseries Liczba wierzchołków & \bfseries Gęstość & \bfseries Czas $[ms]$% specify table head
                    \csvreader[head to column names]{Tests/List_Prima.csv}{}% use head of csv as column names
                    {\\\hline\csvcoli&\csvcolii&\csvcoliii}\\
                    \hline
                \end{tabular}
                \caption{Pomiary algorytmu Prima na liście sąsiedztwa}
            \end{table}

        \subsubsection{Algorytm Kruskala i macierz sąsiedztwa}
            \begin{table}[H]
                \centering
                \begin{tabular}{|c|c|c|}%
                    \hline
                    \bfseries Liczba wierzchołków & \bfseries Gęstość & \bfseries Czas $[ms]$% specify table head
                    \csvreader[head to column names]{Tests/Matrix_Kruskal.csv}{}% use head of csv as column names
                    {\\\hline\csvcoli&\csvcolii&\csvcoliii}\\
                    \hline
                \end{tabular}
                \caption{Pomiary algorytmu Kruskala na macierzy sąsiedztwa}
            \end{table}
            
        \subsubsection{Algorytm Kruskala i lista sąsiedztwa}
            \begin{table}[H]
                \centering
                \begin{tabular}{|c|c|c|}%
                    \hline
                    \bfseries Liczba wierzchołków & \bfseries Gęstość & \bfseries Czas $[ms]$% specify table head
                    \csvreader[head to column names]{Tests/List_Kruskal.csv}{}% use head of csv as column names
                    {\\\hline\csvcoli&\csvcolii&\csvcoliii}\\
                    \hline
                \end{tabular}
                \caption{Pomiary algorytmu Kruskala na liście sąsiedztwa}
            \end{table}

    \subsection{Algorytmy znajdowania najkrótszej ścieżki w grafie}
    
    \subsubsection{Algorytm Dijkstry i macierz sąsiedztwa}
        \begin{table}[H]
            \centering
            \begin{tabular}{|c|c|c|}%
                \hline
                \bfseries Liczba wierzchołków & \bfseries Gęstość & \bfseries Czas $[ms]$% specify table head
                \csvreader[head to column names]{Tests/Matrix_Dijkstra.csv}{}% use head of csv as column names
                {\\\hline\csvcoli&\csvcolii&\csvcoliii}\\
                \hline
            \end{tabular}
            \caption{Pomiary algorytmu Dijkstry na macierzy sąsiedztwa}
        \end{table}

    \subsubsection{Algorytm Dijkstry i lista sąsiedztwa}
        \begin{table}[H]
            \centering
            \begin{tabular}{|c|c|c|}%
                \hline
                \bfseries Liczba wierzchołków & \bfseries Gęstość & \bfseries Czas $[ms]$% specify table head
                \csvreader[head to column names]{Tests/List_Dijkstra.csv}{}% use head of csv as column names
                {\\\hline\csvcoli&\csvcolii&\csvcoliii}\\
                \hline
            \end{tabular}
            \caption{Pomiary algorytmu Dijkstry na liście sąsiedztwa}
        \end{table}

    \subsubsection{Algorytm Bellmana-Forda i macierz sąsiedztwa}
        \begin{table}[H]
            \centering
            \begin{tabular}{|c|c|c|}%
                \hline
                \bfseries Liczba wierzchołków & \bfseries Gęstość & \bfseries Czas $[ms]$% specify table head
                \csvreader[head to column names]{Tests/Matrix_BellmanFord.csv}{}% use head of csv as column names
                {\\\hline\csvcoli&\csvcolii&\csvcoliii}\\
                \hline
            \end{tabular}
            \caption{Pomiary algorytmu Bellmana-Forda na macierzy sąsiedztwa}
        \end{table}
    
    \subsubsection{Algorytm Bellmana-Forda i lista sąsiedztwa}
        \begin{table}[H]
            \centering
            \begin{tabular}{|c|c|c|}%
                \hline
                \bfseries Liczba wierzchołków & \bfseries Gęstość & \bfseries Czas $[ms]$% specify table head
                \csvreader[head to column names]{Tests/List_BellmanFord.csv}{}% use head of csv as column names
                {\\\hline\csvcoli&\csvcolii&\csvcoliii}\\
                \hline
            \end{tabular}
            \caption{Pomiary algorytmu Bellmana-Forda na liście sąsiedztwa}
        \end{table}

\section{Wykresy}


\section{Wnioski}
    \subsection{Przykładowe wyliczenia}
        W tej sekcji porównane zostaną czasy otrzymane eksperymentalnie z tymi wynikającymi z teorii. Porównywane będą zależności
        czasu wykonania danych operacji dla rozmiarów:


    \subsection{Komentarz}
       
\end{document}
